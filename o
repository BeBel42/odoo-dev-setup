#!/usr/bin/env bash

# Usage: this is a convenience script to quickly start and reload odoo.
# It was made to prevent tiresome, manual operations to reboot the containers.

set -eu

# TODO make a scaffold argument to call odoo-bin scaffold
# NOTE then the created dir will be of chown root:root so change that afterwards

project_dir=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)
community_dir="$project_dir/community"
enterprise_dir="$project_dir/enterprise"
upgrade_dir="$project_dir/upgrade"

cd "$project_dir"

# Options that do not work in .odoorc
config_param="--config=./.odoorc"
default_args="--dev=all --limit-time-real=0 --limit-time-cpu=0 --limit-time-worker-cron=0 --max-cron-threads=0 $config_param"

error() {
    error_message="
$0 usage:
	-m | --module <module_list>
		Select the module to update / install.
		It can also be a comma-separated module_name list.
	-d | --drop
		Drop the database to start on an empty session.
		This will automatically reinstall the module.
	-i | --install
		Installs the module in the database.
	-s | --stop
		Stop all containers
	-u | --upgrade
		Run upgrade scripts for module (specified with -m)
	-t | --test [-][tag][/module][:class][.method][[params]]
		Enables testing for filtered tests.
		The '-' specifies whether to include or to exclude matched tests.
		Example: -t :TestClass.test_func,/test_module,external
		It is also possible to provide parameters to a test method that supports
		them. Example: -t /web.test_js[mail]
	--checkout-community <branch>
		Checkout community repository to <branch>
	--checkout-enterprise <branch>
		Checkout enterprise repository to <branch>
	--checkout-upgrade <branch>
		Checkout upgrade repository to <branch>
	--populate <models_list>
		Allows to duplicate existing data in a given database.
		Can be used for testing and benchmarking when large tables are needed.
	--populate-factor <factors_list>
		List of populate factors. In case a factor is missing for a model, the
		last factor in the list will be used. Defaults to 1000.
	-c | --checkout <branch>
		Checkout enterprise and community odoo repositories to <branch>
	-p | --pull
		Pull community/enterprise odoo repositories to the latest changes.
		This will be executed after \"--checkout\" flags if both are specified.
	--pull-upgrade
		Pull the upgrade odoo repository to the latest changes.
		This will be executed after \"--checkout\" flags if both are specified.
	-b | --bash
	   Launches bash in the odoo container (e.g.: to use odoo-bin manually)
	-r | --rebase <branch>
	   Rebases current branches in enterprise/community onto <branch>
	   if \"--pull\" is specified, pulls <branch> before rebasing onto it
	--shell
	   Launches the odoo python shell
	--template <template_name>
		Will drop the current db and refill it with <template_name>'s content
	--save-template <template_name>
		Will launch odoo, immediatly quit when odoo is done setting up the
		modules, then save the current db as <template_name>
	--drop-template <regex>
		Drops all db templates matching <regex>
	--db-list
		List all postgres databases
	--no-restart
		Runs command as 'docker exec' instead of stopping old containers and
		replacing them with a new 'docker run' instance.
	--odoo-help
		Show the help prompt from odoo-bin
	--debug
		Enables debugpy. May crash on live code change.
	--init-only
		Stops odoo after init (e.g.: to only set database)
	--setup
		Sets up the whole project + dependencies
	--odoo-version
		Show the odoo version
    --restore <restore-zip-path>
        Will fill current db with specified zip dump file
    --sync-community-with-enterprise
        Will try to checkout community to the closest matching commit that
        matches enterprise's current commit
    --sync-enterprise-with-community
        Will try to checkout enterprise to the closest matching commit that
        matches community's current commit
    --installed
        Will show all modules that will be installed by modules
        specified by \"--module\"
    --installers
        Will show all modules that can install the modules specified
        by \"--module\"
	-h | --help
		Show this help prompt."
    [[ "$1" = "" ]] || echo "$1" 1>&2
    echo -e "$error_message" 1>&2
}

# default values
drop=0
install=0
help=0
stop=0
module=""
test=""
demo=0
odoo_help=0
odoo_version=0
enable_debug=0
checkout_branch=""
checkout_community=""
checkout_enterprise=""
checkout_upgrade=""
pull_branch=0
pull_upgrade=0
rebase_branch=""
setup=0
template=""
save_template=""
drop_template_regex=""
cmd="$default_args"
db_list=0
upgrade=0
run_bash=0
init_only=0
shell=0
no_restart=0
populate_models=""
populate_factors=1000
sync_community_with_enterprise=0
sync_enterprise_with_community=0
installed=0
installers=0
restore_path=""

# parse script parameters
while [[ "$#" -gt 0 ]]; do
    case $1 in
    -m | --module)
        module="$2"
        shift
        ;;
    -t | --test)
        test="$2"
        shift
        ;;
    --checkout-community)
        checkout_community="$2"
        shift
        ;;
    --checkout-enterprise)
        checkout_enterprise="$2"
        shift
        ;;
    --checkout-upgrade)
        checkout_upgrade="$2"
        shift
        ;;
    -c | --checkout)
        checkout_branch="$2"
        shift
        ;;
    --populate)
        populate_models="$2"
        shift
        ;;
    --populate-factor)
        populate_factors="$2"
        shift
        ;;
    --template)
        template="$2"
        shift
        ;;
    --save-template)
        save_template="$2"
        shift
        ;;
    --drop-template)
        drop_template_regex="$2"
        shift
        ;;
    -r | --rebase)
        rebase_branch="$2"
        shift
        ;;
    --restore)
        restore_path="$2"
        shift
        ;;
    -p | --pull) pull_branch=1 ;;
    --pull-upgrade) pull_upgrade=1 ;;
    -b | --bash) run_bash=1 ;;
    -u | --upgrade) upgrade=1 ;;
    -d | --drop) drop=1 && install=1 ;;
    -i | --install) install=1 ;;
    -s | --stop) stop=1 ;;
    -D | --demo) demo=1 ;;
    --no-restart) no_restart=1 ;;
    --odoo-help) odoo_help=1 ;;
    --shell) shell=1 ;;
    --odoo-version) odoo_version=1 ;;
    --init-only) init_only=1 ;;
    --debug) enable_debug=1 ;;
    --db-list) db_list=1 ;;
    --setup) setup=1 ;;
    --sync-community-with-enterprise) sync_community_with_enterprise=1 ;;
    --sync-enterprise-with-community) sync_enterprise_with_community=1 ;;
    --installed) installed=1 ;;
    --installers) installers=1 ;;
    -h | --help) help=1 ;;
    *)
        error "\033[1;31mError\033[0m: unknown parameter passed: \"$1\""
        exit 1
        ;;
    esac
    shift
done

# show help prompt
if [[ $help = 1 ]]; then
    error ""
    exit 0
fi

# Will execute whenever the script finishes
on_script_exit() {
    odoo_icon_path="$project_dir/images/odoo_logo_small.png"
    if type notify-send 1>/dev/null 2>&1; then
        notify-send "Odoo" "Script execution finished" -t 2000 -u low -i "$odoo_icon_path"
    else
        echo -e "\033[1;33mWarning\033[0m: notify-send is not installed on your system. Notifications won't be sent." 1>&2
    fi
}
trap "on_script_exit" EXIT

compose_file="$project_dir"/docker/docker-compose.yml

# Setup the whole project
if [[ $setup = 1 ]]; then
    echo '"--setup" specified. Calling setup container...'
    docker compose -f "$compose_file" run --build --remove-orphans setup
    # Files created from container are chowned to root. Let's change that
    echo "Setting owner of project to $USER..."
    sudo chown -R "$USER:$USER" .
    ln -s --force ./community/ruff.toml ./ruff.toml
    echo "Done setting up project."
    exit 0
fi

# handle arguments for lib/modules.py
if [[ $installed = 1 ]]; then
    "$project_dir"/lib/modules.py "$community_dir"/addons "$enterprise_dir" -m "$module" --installed
    exit $?
fi
if [[ $installers = 1 ]]; then
    "$project_dir"/lib/modules.py "$community_dir"/addons "$enterprise_dir" -m "$module" --installers
    exit $?
fi

warn_user_if_needed() {
    cd "$project_dir/community" &&
        community_branch=$(git rev-parse --abbrev-ref HEAD)
    cd "$project_dir/enterprise" &&
        enterprise_branch=$(git rev-parse --abbrev-ref HEAD)
    cd "$project_dir"
    if ! [[ "$community_branch" == "$enterprise_branch" ]]; then
        echo -e "\e[33m" # start yellow text
        echo -e "\033[1;33mWarning\033[0m: community and enterprise branches differ.
	community_branch=$community_branch
	enterprise_branch=$enterprise_branch" 1>&2
        echo -e "\e[0m" # end yellow text
    fi
}

# use it to checkout $1 to checkout the closest in time to $2's commit
sync_repo_commit() {
    if [ "$#" -ne 2 ]; then
        echo "Error for $0: two arguments should be passed:
$0 <source_repository> <target_repository>" >&2
        exit 1
    fi

    target_repository="$1"
    source_repository="$2"
    commit_sha=$(git -C "$source_repository" rev-parse HEAD)

    # Get commit timestamp
    timestamp=$(git -C "$source_repository" show -s --format=%ct "$commit_sha")
    timestamp_minute=$(((timestamp / 60 + 1) * 60))
    echo "Commit $commit_sha has timestamp: $timestamp_minute"

    # Find closest commit in before this timestamp in target_repository
    matching_commit=$(git -C "$target_repository" rev-list master --timestamp | awk -v ts="$timestamp_minute" '$1 < ts {print $2, $1}' | sort -k2 -nr | head -n1 | cut -d' ' -f1)

    if [ -z "$matching_commit" ]; then
        echo "❎ No commit found before $timestamp_minute in $target_repository" >&2
        exit 1
    fi

    matching_timestamp=$(git -C "$target_repository" show -s --format=%ct "$matching_commit")

    echo "✔ Source repository: $source_repository"
    echo "  ➡ Checkout on $commit_sha (ts: $timestamp_minute)"
    echo "✔ Target repository : $target_repository"
    echo "  ➡ Closest commit: $matching_commit (ts: $matching_timestamp)"

    git -C "$target_repository" checkout "$matching_commit"
    echo "✅ Checked out $target_repository to match $source_repository."
}

if [[ $sync_community_with_enterprise = 1 ]]; then
    echo "'--sync-community-with-enterprise' has been specified"
    sync_repo_commit "$community_dir" "$enterprise_dir"
    exit 0
fi
if [[ $sync_enterprise_with_community = 1 ]]; then
    echo "'--sync-enterprise-with-community' has been specified"
    sync_repo_commit "$enterprise_dir" "$community_dir"
    exit 0
fi

# Will take care of updating the current branch to target_branch
# Unstaged changes will be handled using git stash
rebase_current_branch() {
    # Define the target branch
    target_branch=$1

    # Get the current branch name
    current_branch=$(git rev-parse --abbrev-ref HEAD)

    if ! git diff-index --quiet HEAD --; then
        echo "Stashing uncommitted changes..."
        git stash push --include-untracked --message "auto-stash before rebase from $current_branch onto $target_branch"
        stashed=1
    else
        stashed=0
    fi

    # Pull the latest changes into the target branch
    if [[ $pull_branch = 1 ]]; then
        echo "Fetching latest changes from origin/$target_branch..."
        git fetch origin "$target_branch"
        echo "Pulling latest changes into $target_branch..."
        git checkout "$target_branch"
        git pull --ff-only origin "$target_branch"
        git checkout "$current_branch"
    else
        echo "\"--pull\" has not been specified. $target_branch won't be pulled"
    fi

    echo "Rebasing $current_branch onto $target_branch..."
    git rebase "$target_branch"

    if [[ $stashed = 1 ]]; then
        echo "Unstashing changes..."
        git stash pop
    fi

    echo "$current_branch has been rebased on $target_branch in $(pwd)"
}

# everything related to git checkout and pull
handle_branch_switch() {
    # default to "-c" value if not specified
    [[ "$checkout_community" = "" ]] && checkout_community="$checkout_branch"
    [[ "$checkout_enterprise" = "" ]] && checkout_enterprise="$checkout_branch"

    # define arrays for mapping of branches to directories
    dirs=("$community_dir" "$enterprise_dir" "$upgrade_dir")
    branches=("$checkout_community" "$checkout_enterprise" "$checkout_upgrade")
    pulls=("$pull_branch" "$pull_branch" "$pull_upgrade")

    # check for unstaged or staged changes in git repositories
    for i in "${!dirs[@]}"; do
        dir="${dirs[$i]}"
        branch="${branches[$i]}"
        should_pull="${pulls[$i]}"

        # no need to do anything for this dir
        if [[ $should_pull = 0 && "$branch" = "" ]]; then
            echo "No need to do git operations for $dir"
            continue
        fi

        cd "$dir" || exit 1
        if ! git diff --cached --quiet; then
            echo -e "\033[1;31mError\033[0m: you cannot pull/checkout when there are staged changes in $dir."
            cd - >/dev/null
            exit 1
        fi
        if ! git diff --quiet; then
            echo -e "\033[1;31mError\033[0m: you cannot pull/checkout when there are unstaged changes in $dir."
            cd - >/dev/null
            exit 1
        fi
        cd - >/dev/null
    done

    # Switch branches in both repositories
    for i in "${!dirs[@]}"; do
        dir="${dirs[$i]}"
        branch="${branches[$i]}"
        should_pull="${pulls[$i]}"

        cd "$dir" || exit 1
        if [[ $branch != "" ]]; then
            echo "Checking out $dir to $branch..."
            git checkout "$branch"
        fi
        if [[ $should_pull = 1 ]]; then
            current_branch="$(git rev-parse --abbrev-ref HEAD)"
            echo '"-p" has been specified.' "Pulling $dir ($current_branch) to latest changes..."
            git pull --ff-only origin "$current_branch"
        fi
        cd - >/dev/null
    done

    echo "Done git branch operations."
}

# it's annoying me most of the time...
#warn_user_if_needed

# Do git operations if needed
if [[ $rebase_branch != "" ]]; then
    echo "\"-r\" has been specified. Rebasing onto $rebase_branch"
    cd "$community_dir"
    rebase_current_branch "$rebase_branch"
    cd "$project_dir"
    cd "$enterprise_dir"
    rebase_current_branch "$rebase_branch"
    cd "$project_dir"
    exit 0
elif [[ $pull_branch = 1 ||
    $pull_upgrade = 1 ||
    "$checkout_community" != "" ||
    "$checkout_enterprise" != "" ||
    "$checkout_branch" != "" ]]; then
    handle_branch_switch
    exit 0
fi

# just stop everything
if [[ $stop = 1 ]]; then
    echo '"-s" has been specified. Stopping all running containers.'
    docker compose -f "$compose_file" down --remove-orphans && echo "Stopped all running containers."
    exit 0
fi

# user did not mention module name (-m | --module <module_name>)
if [[ "$module" = "" ]]; then
    echo -e "\033[1;33mWarning\033[0m: missing module (-m) parameter.
         No module will be updated / installed." 1>&2
else # seeing if installing (-i) or updating (-u) module
    if [[ $install = 1 ]]; then
        echo "\"$( ([[ $drop = 1 ]] && echo '--drop') || echo '--install')\"" \
            'has been specified. Adding "-i" to command'
        action="-i"
    else
        echo '"--install" has not been specified. Adding "-u" to command'
        action="-u"
    fi
    cmd="$cmd $action $module"
fi

if [[ $demo = 1 ]]; then
    echo "-D has been specified. Enabling demo data"
    cmd="$cmd --without-demo=False"
else
    echo "Demo data is disabled"
    cmd="$cmd --without-demo=True"
fi

if [[ $upgrade = 1 ]]; then
    echo "-u has been specified. Enabling upgrade..."
    cmd="$cmd --upgrade-path=upgrade-util/src,upgrade/migrations --stop-after-init --log-level=info"
fi

if [[ $no_restart = 0 ]]; then
    echo "Shutting down everything"
    docker compose -f "$compose_file" down --remove-orphans

    echo "Starting db container..."
    docker compose -f "$compose_file" up -d db
fi

# Wait for database to be up
tries=1
while (! docker compose -f "$compose_file" exec db pg_isready) && [ $tries -lt 5 ]; do
    sleep 0.5
    tries=$(("$tries" + 1))
    echo "Checking database availability ($tries)..."
done
if [ $tries = 5 ]; then
    echo -e "\033[1;31mError\033[0m: could not verify database availability" 1>&2
    exit 1
fi

if [[ $db_list = 1 ]]; then
    echo '"--db-list" has been specified. List of all postgres databases:'
    docker compose -f "$compose_file" exec db sh -c "psql --user=\$POSTGRES_USER -l"
    exit $?
fi

# prefix prepended to all created / deleted database templates
database_template_prefix="odoo_template_"

if ! [[ "$drop_template_regex" = "" ]]; then
    docker compose -f "$compose_file" exec db sh -c "psql --user=\$POSTGRES_USER -lqt | cut -d \| -f 1 | \
		grep -E '$database_template_prefix""$drop_template_regex' |
		xargs -n 1 dropdb --user=\$POSTGRES_USER --if-exists 2>/dev/null" &&
        echo "All matched templates have been deleted" ||
        echo -e "\033[1;33mWarning\033[0m: no template matched the given regex: $drop_template_regex" 1>&2
    exit 0
fi

if [[ $drop = 1 ]]; then
    echo '"--drop" has been specified. Dropping postgres database...'
    docker compose -f "$compose_file" exec db sh -c "dropdb --user=\$POSTGRES_USER \$POSTGRES_DB" &&
        echo "Database dropped" ||
        echo -e "\033[1;33mWarning\033[0m: failed to drop datatbase" 1>&2
fi

if ! [[ "$template" = "" ]]; then
    echo "\"--template\" has been specified. Copying template $template to current db..."
    (docker compose -f "$compose_file" exec db sh -c "
        dropdb --if-exists --user=\"\$POSTGRES_USER\" \"\$POSTGRES_DB\" && \
        createdb --user=\"\$POSTGRES_USER\" -T \"$database_template_prefix""$template\" \"\$POSTGRES_DB\"
    " && echo "Successfully copied template $template") ||
        (echo -e "\033[1;31mError\033[0m: could not use template $template" 1>&2 && exit 1)
fi

if ! [[ "$test" = "" ]]; then
    echo '"-t" has been specified. Adding test arguments to cmd'
    cmd="$cmd --stop-after-init --log-level=test --test-enable --test-tags=$test"
    if [[ "$module" = "" ]]; then
        echo -e "\033[1;33mWarning\033[0m: no module has been set to be \
			tracked (-m) or installed (-i). Tests may not work." 1>&2
    fi
fi

if ! [[ "$save_template" = "" ]]; then
    echo '"--save-template" has been specified. Adding arguments to cmd'
    cmd="$cmd --stop-after-init --log-level=info"
fi

if [[ $init_only = 1 ]]; then
    echo '"--init-only" has been specified. Adding arguments to cmd'
    cmd="$cmd --stop-after-init --log-level=info"
fi

if [[ $odoo_version = 1 ]]; then
    echo '--odoo-version has been specified. Overriding parameters to --version'
    cmd="--version"
fi

if [[ $shell = 1 ]]; then
    echo '"--shell" has ben specified. Overriding parameters to "shell"'
    cmd="shell $config_param"
fi

if [[ $populate_models != "" ]]; then
    echo '"--populate" has ben specified. Overriding cmd parameters...'
    echo "Set to populate $populate_models by a factor of $populate_factors"
    cmd="populate --models $populate_models --factors $populate_factors"
fi

if [[ $odoo_help = 1 ]]; then
    echo '--odoo-help has been specified. Overriding parameters to --help'
    cmd="--help"
fi

docker_entrypoint=""
docker_build="--build"
docker_run_exec="run"
docker_service_ports="--service-ports"
docker_volumes=""
# attach to process if no restart
if [[ $no_restart = 1 ]]; then
    echo "\"--no-restart\" has been specified. Changing docker command.."
    docker_run_exec="exec"
    docker_build=""
    docker_service_ports=""
    cmd="bash ./entrypoint.bash $cmd"
fi
# remove cmd if using bash
if [[ $run_bash = 1 ]]; then
    echo "\"-b\" has been specified. Launching bash console from odoo container..."
    docker_entrypoint='--entrypoint="/bin/bash"'
    cmd=""
fi
if [[ $restore_path != '' ]]; then
    echo '"--restore_path" has been specified. Overriding arguments to "db load"'
    cmd="db -c .odoorc load -f odoo /tmp/restore-dump.zip"
    echo "Adding $restore_path as a docker volume"
    docker_volumes="-v $restore_path:/tmp/restore-dump.zip"
fi

echo "Starting odoo container with \"$cmd\" parameters..."
docker compose -f "$compose_file" $docker_run_exec $docker_volumes $docker_build -e "ENABLE_DEBUG=$enable_debug" $docker_service_ports $docker_entrypoint odoo $cmd

if [[ ! "$save_template" = "" ]]; then
    echo "--save-template specified. Saving db into template \"$save_template\""
    # Need to drop the old save template to avoid errors when overriding it
    docker compose -f "$compose_file" exec db sh -c "dropdb --if-exists --user=\"\$POSTGRES_USER\" '$database_template_prefix""$save_template' 2>/dev/null" ||
        echo -e "\033[1;33mWarning\033[0m: failed to drop old \"$save_template\" template" 1>&2
    docker compose -f "$compose_file" exec db sh -c "createdb --user=\"\$POSTGRES_USER\" -T \"\$POSTGRES_DB\" '$database_template_prefix""$save_template'" &&
        echo "Template saved" ||
        echo -e "\033[1;33mWarning\033[0m: failed to create template datatbase" 1>&2
fi
